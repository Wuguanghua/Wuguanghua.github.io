<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="VvyjvVXcJQa0QklHipu6pwm2PJGnnchIqX7s5JbbT_0" />




















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文为 js 知识的一些总结，总结于阮一峰《javaScript 标准参考教程》部分知识点。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 知识总结">
<meta property="og:url" content="https://wuguanghua.github.io/2018/09/24/知识总结/index.html">
<meta property="og:site_name" content="Guanghua &#39;s blog">
<meta property="og:description" content="本文为 js 知识的一些总结，总结于阮一峰《javaScript 标准参考教程》部分知识点。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg">
<meta property="og:updated_time" content="2018-09-24T15:02:35.981Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 知识总结">
<meta name="twitter:description" content="本文为 js 知识的一些总结，总结于阮一峰《javaScript 标准参考教程》部分知识点。">
<meta name="twitter:image" content="https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg">






  <link rel="canonical" href="https://wuguanghua.github.io/2018/09/24/知识总结/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JavaScript 知识总结 | Guanghua 's blog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2253e9637f1f23584360886c5ee34cac";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/Wuguanghua"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Guanghua 's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">guanghua</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wuguanghua.github.io/2018/09/24/知识总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wuguanghua">
      <meta itemprop="description" content="to be better!">
      <meta itemprop="image" content="https://raw.githubusercontent.com/Wuguanghua/Wuguanghua.github.io/master/images/touxaing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guanghua 's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript 知识总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-24 22:51:41 / 修改时间：23:02:35" itemprop="dateCreated datePublished" datetime="2018-09-24T22:51:41+08:00">2018-09-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/09/24/知识总结/" class="leancloud_visitors" data-flag-title="JavaScript 知识总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg" alt="banner"></p>
<p>本文为 js 知识的一些总结，总结于阮一峰《javaScript 标准参考教程》部分知识点。</p>
<a id="more"></a>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><ol>
<li>由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 1; &lt;!-- x = 2;</span><br><span class="line">--&gt; x = 3;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码中，只有x = 1会执行，其他的部分都被注释掉了。</p>
<p>需要注意的是，–&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function countdown(n) &#123;</span><br><span class="line">  while (n --&gt; 0) console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">countdown(3)</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure>
<p>上面代码中，n –&gt; 0实际上会当作n– &gt; 0，因此输出2、1、0。</p>
<h3 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2.条件语句"></a>2.条件语句</h3><ol>
<li>switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line">switch (x) &#123;</span><br><span class="line">  case true:</span><br><span class="line">    console.log(&apos;x 发生类型转换&apos;);</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    console.log(&apos;x 没有发生类型转换&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// x 没有发生类型转换</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”。</p>
<ol start="2">
<li>for 循环的运行顺序</li>
</ol>
<ul>
<li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li>
<li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li>
<li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 3;</span><br><span class="line">for (var i = 0; i &lt; x; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。</p>
<ol start="3">
<li>break 和 continue</li>
</ol>
<p>break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  if (i === 3)</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
<p>上面代码执行到i等于3，就会跳出循环。</p>
<p>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var i = 0;</span><br><span class="line"></span><br><span class="line">while (i &lt; 100)&#123;</span><br><span class="line">  i++;</span><br><span class="line">  if (i % 2 === 0) continue;</span><br><span class="line">  console.log(&apos;i 当前为：&apos; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。</p>
<p>如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。</p>
<h3 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h3><blockquote>
<p>这个还真没用过；</p>
</blockquote>
<p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p>
<p><code>label: 语句</code></p>
<p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p>
<p>标签通常与break语句和continue语句配合使用，跳出特定的循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) break top;</span><br><span class="line">      console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// i=0, j=0</span><br><span class="line">// i=0, j=1</span><br><span class="line">// i=0, j=2</span><br><span class="line">// i=1, j=0</span><br></pre></td></tr></table></figure>
<p>上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<p>标签也可以用于跳出代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  break foo;</span><br><span class="line">  console.log(&apos;本行不会输出&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(2);</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
<p>上面代码执行到break foo，就会跳出区块。</p>
<p>continue语句也可以与标签配合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) continue top;</span><br><span class="line">      console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// i=0, j=0</span><br><span class="line">// i=0, j=1</span><br><span class="line">// i=0, j=2</span><br><span class="line">// i=1, j=0</span><br><span class="line">// i=2, j=0</span><br><span class="line">// i=2, j=1</span><br><span class="line">// i=2, j=2</span><br></pre></td></tr></table></figure>
<p>上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="1-typeof-运算符"><a href="#1-typeof-运算符" class="headerlink" title="1.typeof 运算符"></a>1.typeof 运算符</h4><p> JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>
<ul>
<li><p><code>typeof</code>运算符</p>
</li>
<li><p><code>instanceof</code>运算符</p>
</li>
<li><p><code>Object.prototype.toString</code>方法</p>
</li>
</ul>
<p>typeof运算符可以返回一个值的数据类型。</p>
<p>数值、字符串、布尔值分别返回number、string、boolean。</p>
<p>函数返回function。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f</span><br><span class="line">// &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p>undefined返回undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined</span><br><span class="line">// &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v</span><br><span class="line">// ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">typeof v</span><br><span class="line">// &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>实际编程中，这个特点通常用在判断语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">if (v) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">if (typeof v === &quot;undefined&quot;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象返回object。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof window // &quot;object&quot;</span><br><span class="line">typeof &#123;&#125; // &quot;object&quot;</span><br><span class="line">typeof [] // &quot;object&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">o instanceof Array // false</span><br><span class="line">a instanceof Array // true</span><br></pre></td></tr></table></figure>
<p>null返回object。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null // &quot;object&quot;</span><br></pre></td></tr></table></figure>
<p>null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。</p>
<h3 id="null-undefined-和布尔值"><a href="#null-undefined-和布尔值" class="headerlink" title="null, undefined 和布尔值"></a>null, undefined 和布尔值</h3><h4 id="在if语句中，它们都会被自动转为false，相等运算符（-）甚至直接报告两者相等。"><a href="#在if语句中，它们都会被自动转为false，相等运算符（-）甚至直接报告两者相等。" class="headerlink" title="在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。"></a>在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!undefined) &#123;</span><br><span class="line">  console.log(&apos;undefined is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// undefined is false</span><br><span class="line"></span><br><span class="line">if (!null) &#123;</span><br><span class="line">  console.log(&apos;null is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// null is false</span><br><span class="line"></span><br><span class="line">undefined == null</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>根据 C 语言的传统，null可以自动转为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(null) // 0</span><br><span class="line">5 + null // 5</span><br></pre></td></tr></table></figure>
<p>上面代码中，null转为数字时，自动变成0。</p>
<p>null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(undefined) // NaN</span><br><span class="line">5 + undefined // NaN</span><br></pre></td></tr></table></figure>
<h5 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h5><p>对于null和undefined，大致可以像下面这样理解。</p>
<p>null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。</p>
<p>undefined表示“未定义”，下面是返回undefined的典型场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 变量声明了，但没有赋值</span><br><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="line">function f(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">// 对象没有赋值的属性</span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">// 函数没有返回值时，默认返回 undefined</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">f() // undefined</span><br></pre></td></tr></table></figure>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>0</li>
<li>NaN</li>
<li>“”或’’（空字符串）</li>
</ul>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><ol>
<li>NaN</li>
</ol>
<p>NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 - &apos;x&apos; // NaN</span><br></pre></td></tr></table></figure>
<p>上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。</p>
<p>需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof NaN // &apos;number&apos;</span><br></pre></td></tr></table></figure>
<p>数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN) // -1</span><br></pre></td></tr></table></figure>
<p>NaN在布尔运算时被当作false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean(NaN) // false</span><br></pre></td></tr></table></figure>
<p>NaN与任何数（包括它自己）的运算，得到的都是NaN。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NaN + 32 // NaN</span><br><span class="line">NaN - 32 // NaN</span><br><span class="line">NaN * 32 // NaN</span><br><span class="line">NaN / 32 // NaN</span><br></pre></td></tr></table></figure>
<h4 id="数值相关的全局方法"><a href="#数值相关的全局方法" class="headerlink" title="数值相关的全局方法"></a>数值相关的全局方法</h4><p><strong>parseInt()</strong></p>
<p>parseInt方法用于将字符串转为整数；</p>
<p>如果字符串头部有空格，空格会被自动去除；</p>
<p>如果parseInt的参数不是字符串，则会先转为字符串再转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(1.23) // 1</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&apos;1.23&apos;) // 1</span><br></pre></td></tr></table></figure>
<p>进制转换</p>
<p>parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1000&apos;) // 1000</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&apos;1000&apos;, 10) // 1000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parseInt(&apos;1000&apos;, 2) // 8</span><br><span class="line">parseInt(&apos;1000&apos;, 6) // 216</span><br><span class="line">parseInt(&apos;1000&apos;, 8) // 512</span><br></pre></td></tr></table></figure>
<p><strong>parseFloat()</strong></p>
<p>parseFloat方法用于将一个字符串转为浮点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&apos;3.14&apos;) // 3.14</span><br><span class="line"></span><br><span class="line">parseFloat(&apos;314e-2&apos;) // 3.14</span><br><span class="line">parseFloat(&apos;0.0314E+2&apos;) // 3.14</span><br></pre></td></tr></table></figure>
<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseFloat([]) // NaN</span><br><span class="line">parseFloat(&apos;FF2&apos;) // NaN</span><br><span class="line">parseFloat(&apos;&apos;) // NaN</span><br></pre></td></tr></table></figure>
<p><strong>isNaN()</strong></p>
<p>isNaN方法可以用来判断一个值是否为NaN。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN) // true</span><br><span class="line">isNaN(123) // false</span><br></pre></td></tr></table></figure>
<p>但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&apos;Hello&apos;) // true</span><br><span class="line">// 相当于</span><br><span class="line">isNaN(Number(&apos;Hello&apos;)) // true</span><br></pre></td></tr></table></figure>
<p>出于同样的原因，对于对象和数组，isNaN也返回true。</p>
<p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。</p>
<p><strong>判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>isFinite()</strong></p>
<p>isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isFinite(Infinity) // false</span><br><span class="line">isFinite(-Infinity) // false</span><br><span class="line">isFinite(NaN) // false</span><br><span class="line">isFinite(undefined) // false</span><br><span class="line">isFinite(null) // true</span><br><span class="line">isFinite(-1) // true</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>Base64 转码</li>
</ol>
<p>JavaScript 原生提供两个 Base64 相关的方法。</p>
<ul>
<li>btoa()：任意值转为 Base64 编码</li>
<li>atob()：Base64 编码转为原来的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &apos;Hello World!&apos;;</span><br><span class="line">btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;</span><br><span class="line">atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>
<p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btoa(&apos;你好&apos;) // 报错</span><br></pre></td></tr></table></figure>
<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function b64Encode(str) &#123;</span><br><span class="line">  return btoa(encodeURIComponent(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b64Decode(str) &#123;</span><br><span class="line">  return decodeURIComponent(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span><br><span class="line">b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot;</span><br></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><h5 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h5><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = 1;</span><br><span class="line">o2.a // 1</span><br><span class="line"></span><br><span class="line">o2.b = 2;</span><br><span class="line">o1.b // 2</span><br></pre></td></tr></table></figure>
<p>取消某一个变量对于原对象的引用，不会影响到另一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = 1;</span><br><span class="line">o2 // &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看一个对象本身的所有属性，可以使用Object.keys方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  key1: 1,</span><br><span class="line">  key2: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj);</span><br><span class="line">// [&apos;key1&apos;, &apos;key2&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>属性是否存在：in 运算符</strong></p>
<p>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">&apos;p&apos; in obj // true</span><br><span class="line">&apos;toString&apos; in obj // true</span><br></pre></td></tr></table></figure>
<p>in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。</p>
<p>这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">if (&apos;toString&apos; in obj) &#123;</span><br><span class="line">  console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>属性的遍历：for…in 循环</strong></p>
<p>for…in循环用来遍历一个对象的全部属性。</p>
<p>for…in循环有两个使用注意点。</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p>举例来说，对象都继承了toString属性，但是for…in循环不会遍历到这个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// toString 属性是存在的</span><br><span class="line">obj.toString // toString() &#123; [native code] &#125;</span><br><span class="line"></span><br><span class="line">for (var p in obj) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125; // 没有任何输出</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象obj继承了toString属性，该属性不会被for…in循环遍历到，因为它默认是“不可遍历”的。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p> <strong>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> var a = 1;</span><br><span class="line">var x = function () &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure>
<p> 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。</p>
<h5 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h5><ol>
<li>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</li>
</ol>
<p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>
<p><em>正常模式下，arguments对象可以在运行时修改。
</em>严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。<br>*通过arguments对象的length属性，可以判断函数调用时到底带几个参数。</p>
<ol start="2">
<li>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</li>
</ol>
<p>如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">var args = [];</span><br><span class="line">for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">  args.push(arguments[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>arguments对象带有一个callee属性，返回它所对应的原函数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(arguments.callee === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // true</span><br></pre></td></tr></table></figure>
<p>*可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中。</p>
<p>闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createIncrementor(start) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var inc = createIncrementor(5);</span><br><span class="line"></span><br><span class="line">inc() // 5</span><br><span class="line">inc() // 6</span><br><span class="line">inc() // 7</span><br></pre></td></tr></table></figure>
<p>上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  var _age;</span><br><span class="line">  function setAge(n) &#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  function getAge() &#123;</span><br><span class="line">    return _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = Person(&apos;张三&apos;);</span><br><span class="line">p1.setAge(25);</span><br><span class="line">p1.getAge() // 25</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。</p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h4><p> 如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> var obj = &#123;</span><br><span class="line">  0: &apos;a&apos;,</span><br><span class="line">  1: &apos;b&apos;,</span><br><span class="line">  2: &apos;c&apos;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[0] // &apos;a&apos;</span><br><span class="line">obj[1] // &apos;b&apos;</span><br><span class="line">obj.length // 3</span><br><span class="line">obj.push(&apos;d&apos;) // TypeError: obj.push is not a function</span><br></pre></td></tr></table></figure>
<p> 上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。</p>
<p>“类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。</p>
<p><strong>典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。</strong></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><h3 id="基本规则："><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h3><p>  JavaScript 允许非数值的相加。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  true + true // 2</span><br><span class="line">1 + true // 2</span><br></pre></td></tr></table></figure>
<p>  上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加。</p>
<p>比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; + &apos;bc&apos; // &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p>如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + &apos;a&apos; // &quot;1a&quot;</span><br><span class="line">false + &apos;a&apos; // &quot;falsea&quot;</span><br></pre></td></tr></table></figure></p>
<p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 - &apos;2&apos; // -1</span><br><span class="line">1 * &apos;2&apos; // 2</span><br><span class="line">1 / &apos;2&apos; // 0.5</span><br></pre></td></tr></table></figure>
<p><strong>对象的相加</strong></p>
<p>如果运算子是对象，必须先转成原始类型的值，然后再相加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象obj转成原始类型的值是[object Object]，再加2就得到了上面的结果。</p>
<p>对象转成原始类型的值，规则如下。</p>
<p>首先，自动调用对象的valueOf方法。</p>
<figure class="highlight plain"><figcaption><span>obj </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.valueOf() // &#123; p: 1 &#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。</p>
<figure class="highlight plain"><figcaption><span>obj </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.valueOf().toString() // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>对象的toString方法默认返回[object Object]，所以就得到了最前面那个例子的结果。</p>
<p>知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。</p>
<p><strong>余数运算</strong></p>
<p>余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。</p>
<p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定。</p>
<figure class="highlight plain"><figcaption><span>% 2</span><a href="//">-1</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 % -2 // 1</span><br></pre></td></tr></table></figure>
<p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p>
<p><strong>数值运算符（+）</strong></p>
<p>数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+true // 1</span><br><span class="line">+[] // 0</span><br><span class="line">+&#123;&#125; // NaN</span><br></pre></td></tr></table></figure></p>
<p><strong>指数运算符 </strong></p>
<p>指数运算符（ **  完成指数运算，前一个运算子是底数，后一个运算子是指数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 ** 4 // 16</span><br></pre></td></tr></table></figure>
<p>注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。</p>
<figure class="highlight plain"><figcaption><span>相当于 2 ** (3 ** 2)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ** 3 ** 2</span><br><span class="line">// 512</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个。</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p> <strong>严格相等运算符 JavaScript 提供两种相等运算符：==和===。</strong></p>
<p> 它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1 === &quot;1&quot; // false</span><br><span class="line">true === &quot;true&quot; // false</span><br></pre></td></tr></table></figure>
<p> undefined和null与自身严格相等。</p>
<p>由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。</p>
<p><strong>严格不相等运算符</strong></p>
<p>严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 !== &apos;1&apos; // true</span><br><span class="line">// 等同于</span><br><span class="line">!(1 === &apos;1&apos;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，感叹号!是求出后面表达式的相反值。</p>
<p><strong>相等运算符</strong></p>
<p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。</p>
<p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1 == true // true</span><br><span class="line">// 等同于 1 === Number(true)</span><br><span class="line"></span><br><span class="line">0 == false // true</span><br><span class="line">// 等同于 0 === Number(false)</span><br><span class="line"></span><br><span class="line">2 == true // false</span><br><span class="line">// 等同于 2 === Number(true)</span><br><span class="line"></span><br><span class="line">2 == false // false</span><br><span class="line">// 等同于 2 === Number(false)</span><br><span class="line"></span><br><span class="line">&apos;true&apos; == true // false</span><br><span class="line">// 等同于 Number(&apos;true&apos;) === Number(true)</span><br><span class="line">// 等同于 NaN === 1</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0 // true</span><br><span class="line">// 等同于 Number(&apos;&apos;) === 0</span><br><span class="line">// 等同于 0 === 0</span><br><span class="line"></span><br><span class="line">&apos;&apos; == false  // true</span><br><span class="line">// 等同于 Number(&apos;&apos;) === Number(false)</span><br><span class="line">// 等同于 0 === 0</span><br><span class="line"></span><br><span class="line">&apos;1&apos; == true  // true</span><br><span class="line">// 等同于 Number(&apos;1&apos;) === Number(true)</span><br><span class="line">// 等同于 1 === 1</span><br><span class="line"></span><br><span class="line">&apos;\n  123  \t&apos; == 123 // true</span><br><span class="line">// 因为字符串转为数字时，省略前置和后置的空格</span><br></pre></td></tr></table></figure>
<p>对象与原始类型值比较</p>
<p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 对象与数值比较时，对象转为数值</span><br><span class="line">[1] == 1 // true</span><br><span class="line">// 等同于 Number([1]) == 1</span><br><span class="line"></span><br><span class="line">// 对象与字符串比较时，对象转为字符串</span><br><span class="line">[1] == &apos;1&apos; // true</span><br><span class="line">// 等同于 String([1]) == &apos;1&apos;</span><br><span class="line">[1, 2] == &apos;1,2&apos; // true</span><br><span class="line">// 等同于 String([1, 2]) == &apos;1,2&apos;</span><br><span class="line"></span><br><span class="line">// 对象与布尔值比较时，两边都转为数值</span><br><span class="line">[1] == true // true</span><br><span class="line">// 等同于 Number([1]) == Number(true)</span><br><span class="line">[2] == true // false</span><br><span class="line">// 等同于 Number([2]) == Number(true)</span><br></pre></td></tr></table></figure>
<p>相等运算符的缺点</p>
<p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。</p>
<p><em>undefined
</em>null<br><em>false
</em>0<br><em>NaN
</em>空字符串（’’）</p>
<p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 等同于</span><br><span class="line">Boolean(x)</span><br></pre></td></tr></table></figure>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p><strong>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</strong></p>
<p>这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p><strong>原始类型值的转换规则</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 数值：转换后还是原来的值</span><br><span class="line">Number(324) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="line">Number(&apos;324&apos;) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="line">Number(&apos;324abc&apos;) // NaN</span><br><span class="line"></span><br><span class="line">// 空字符串转为0</span><br><span class="line">Number(&apos;&apos;) // 0</span><br><span class="line"></span><br><span class="line">// 布尔值：true 转成 1，false 转成 0</span><br><span class="line">Number(true) // 1</span><br><span class="line">Number(false) // 0</span><br><span class="line"></span><br><span class="line">// undefined：转成 NaN</span><br><span class="line">Number(undefined) // NaN</span><br><span class="line"></span><br><span class="line">// null：转成0</span><br><span class="line">Number(null) // 0</span><br></pre></td></tr></table></figure>
<p>Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。</p>
<figure class="highlight plain"><figcaption><span>cats')</span><a href="//">42</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;42 cats&apos;) // NaN</span><br></pre></td></tr></table></figure>
<p>上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。</p>
<p>另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;\t\v\r12.34\n&apos;) // 12</span><br><span class="line">Number(&apos;\t\v\r12.34\n&apos;) // 12.34</span><br></pre></td></tr></table></figure></p>
<p><strong>对象</strong></p>
<p>简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#123;a: 1&#125;) // NaN</span><br><span class="line">Number([1, 2, 3]) // NaN</span><br><span class="line">Number([5]) // 5</span><br></pre></td></tr></table></figure>
<h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><p><strong>规则：</strong></p>
<ol>
<li>原始类型：</li>
</ol>
<p>数值：转为相应的字符串。<br>字符串：转换后还是原来的值。<br>布尔值：true转为字符串”true”，false转为字符串”false”。<br>undefined：转为字符串”undefined”。<br>null：转为字符串”null”。</p>
<ol start="2">
<li>对象</li>
</ol>
<p>String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String(&#123;a: 1&#125;) // &quot;[object Object]&quot;</span><br><span class="line">String([1, 2, 3]) // &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure>
<p>String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。</p>
<ol>
<li><p>先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。</p>
</li>
<li><p>如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。</p>
</li>
<li><p>如果valueOf方法返回的是对象，就报错。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String(&#123;a: 1&#125;)</span><br><span class="line">// &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">String(&#123;a: 1&#125;.toString())</span><br><span class="line">// &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。</p>
<p><strong>Boolean()</strong></p>
<p>规则：</p>
<p>它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。</p>
<p>undefined<br>null<br>-0或+0<br>NaN<br>‘’（空字符串）</p>
<p>注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(0) // false</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line">Boolean(&apos;&apos;) // false</span><br><span class="line"></span><br><span class="line">Boolean(&#123;&#125;) // true</span><br><span class="line">Boolean([]) // true</span><br><span class="line">Boolean(new Boolean(false)) // true</span><br></pre></td></tr></table></figure>
<p><strong>自动转换为字符串</strong></p>
<p>具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。</p>
<p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5&apos; + 1 // &apos;51&apos;</span><br><span class="line">&apos;5&apos; + true // &quot;5true&quot;</span><br><span class="line">&apos;5&apos; + false // &quot;5false&quot;</span><br><span class="line">&apos;5&apos; + &#123;&#125; // &quot;5[object Object]&quot;</span><br><span class="line">&apos;5&apos; + [] // &quot;5&quot;</span><br><span class="line">&apos;5&apos; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;</span><br><span class="line">&apos;5&apos; + undefined // &quot;5undefined&quot;</span><br><span class="line">&apos;5&apos; + null // &quot;5null&quot;</span><br></pre></td></tr></table></figure>
<p><strong>自动转换为数值</strong></p>
<p>除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;5&apos; - &apos;2&apos; // 3   5 -2</span><br><span class="line">&apos;5&apos; * &apos;2&apos; // 10  5 * 2</span><br><span class="line">true - 1  // 0   1 - 1</span><br><span class="line">false - 1 // -1  0 - 1</span><br><span class="line">&apos;1&apos; - 1   // 0   1 - 1</span><br><span class="line">&apos;5&apos; * []    // 0 5 * 0</span><br><span class="line">false / &apos;5&apos; // 0  0 / 5</span><br><span class="line">&apos;abc&apos; - 1   // NaN NaN -1</span><br><span class="line">null + 1 // 1 0 + 1</span><br><span class="line">undefined + 1 // NaN  NaN + 1</span><br></pre></td></tr></table></figure>
<h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><h3 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h3><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。</p>
<figure class="highlight plain"><figcaption><span>err </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err.message // &quot;出错了&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们调用Error构造函数，生成一个实例对象err。Error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛出Error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p>
<p>Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。</p>
<h3 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h3><ol>
<li>ntaxError 对象</li>
</ol>
<p>SyntaxError对象是解析代码时发生的语法错误。</p>
<ol start="2">
<li>ReferenceError 对象</li>
</ol>
<p>ReferenceError对象是引用一个不存在的变量时发生的错误。</p>
<ol start="3">
<li>RangeError 对象</li>
</ol>
<p>RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 数组长度不得为负数</span><br><span class="line">new Array(-1)</span><br><span class="line">// Uncaught RangeError: Invalid array length</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>TypeError 对象 </li>
</ol>
<p>TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new 123</span><br><span class="line">// Uncaught TypeError: number is not a func</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line">// Uncaught TypeError: obj.unknownMethod is not a function</span><br></pre></td></tr></table></figure>
<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出TypeError错误,因为obj.unknownMethod的值是undefined，而不是一个函数。</p>
<ol start="5">
<li>URIError 对象</li>
</ol>
<p>URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p>
<ol start="6">
<li>EvalError 对象</li>
</ol>
<p>*eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>
<p>throw语句的作用是手动中断程序执行，抛出一个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (x &lt;= 0) &#123;</span><br><span class="line">  throw new Error(&apos;x 必须为正数&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// Uncaught ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></p>
<h2 id="控制台-console"><a href="#控制台-console" class="headerlink" title="控制台 console"></a>控制台 console</h2><p>如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos; %s + %s = %s&apos;, 1, 1, 2)</span><br><span class="line">//  1 + 1 = 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，console.log方法的第一个参数有三个占位符（%s），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><p><strong>Object 的静态方法</strong></p>
<p>Object.keys()，Object.getOwnPropertyNames()</p>
<p><strong>toString() 的应用：判断数据类型</strong></p>
<p>Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.toString() // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码调用空对象的toString方法，结果返回一个字符串object Object，其中第二个Object表示该值的构造函数。这是一个十分有用的判断数据类型的方法。</p>
<p>由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p>
<p><code>Object.prototype.toString.call(value)</code></p>
<p>上面代码表示对value这个值调用Object.prototype.toString方法。</p>
<p>不同数据类型的Object.prototype.toString方法返回值如下。</p>
<ul>
<li>数值：返回[object Number]。</li>
<li>字符串：返回[object String]。</li>
<li>布尔值：返回[object Boolean]。</li>
<li>undefined：返回[object Undefined]。</li>
<li>null：返回[object Null]。</li>
<li>数组：返回[object Array]。</li>
<li>arguments 对象：返回[object Arguments]。</li>
<li>函数：返回[object Function]。</li>
<li>Error 对象：返回[object Error]。</li>
<li>Date 对象：返回[object Date]。</li>
<li>RegExp 对象：返回[object RegExp]。</li>
<li>其他对象：返回[object Object]。</li>
</ul>
<p>这就是说，Object.prototype.toString可以看出一个值到底是什么类型。</p>
<p>利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。</p>
<figure class="highlight plain"><figcaption><span>type </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  var s = Object.prototype.toString.call(o);</span><br><span class="line">  return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type(&#123;&#125;); // &quot;object&quot;</span><br><span class="line">type([]); // &quot;array&quot;</span><br><span class="line">type(5); // &quot;number&quot;</span><br><span class="line">type(null); // &quot;null&quot;</span><br><span class="line">type(); // &quot;undefined&quot;</span><br><span class="line">type(/abcd/); // &quot;regex&quot;</span><br><span class="line">type(new Date()); // &quot;date&quot;</span><br></pre></td></tr></table></figure>
<p>在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。</p>
<p><strong>Object.prototype.hasOwnProperty()</strong></p>
<p>Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>obj.hasOwnProperty(‘p’) // true<br>obj.hasOwnProperty(‘toString’) // false<br>上面代码中，对象obj自身具有p属性，所以返回true。toString属性是继承的，所以返回false。</p>
<h2 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>Array.isArray()</strong> </p>
<p>Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">typeof arr // &quot;object&quot;</span><br><span class="line">Array.isArray(arr) // true</span><br></pre></td></tr></table></figure>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><strong>1. valueOf()，toString()</strong></p>
<p>数组的valueOf方法返回数组本身。</p>
<p><code>var arr = [1, 2, 3];
arr.valueOf() // [1, 2, 3]</code></p>
<p>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.toString() // &quot;1,2,3&quot;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, [4, 5, 6]];</span><br><span class="line">arr.toString() // &quot;1,2,3,4,5,6&quot;</span><br></pre></td></tr></table></figure>
<p><strong>2. slice()</strong></p>
<p>slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)</span><br><span class="line">// [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));</span><br><span class="line">Array.prototype.slice.call(arguments);</span><br></pre></td></tr></table></figure>
<p><strong>3. splice()</strong></p>
<p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。<strong>注意，该方法会改变原数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure>
<p>splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line">a.splice(4, 2, 1, 2) // [&quot;e&quot;, &quot;f&quot;]</span><br><span class="line">a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span><br></pre></td></tr></table></figure>
<p>上面代码除了删除成员，还插入了两个新成员。</p>
<p><strong>4. map()</strong></p>
<p>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">[1, 2].map(function (e) &#123;</span><br><span class="line">  return this[e];</span><br><span class="line">&#125;, arr)</span><br><span class="line">// [&apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p>上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。</p>
<p><strong>5. forEach()</strong></p>
<p>forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。</p>
<p>forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function log(element, index, array) &#123;</span><br><span class="line">  console.log(&apos;[&apos; + index + &apos;] = &apos; + element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[2, 5, 9].forEach(log);</span><br><span class="line">// [0] = 2</span><br><span class="line">// [1] = 5</span><br><span class="line">// [2] = 9</span><br></pre></td></tr></table></figure>
<p>forEach方法也可以接受第二个参数，绑定参数函数的this变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var out = [];</span><br><span class="line"></span><br><span class="line">[1, 2, 3].forEach(function(elem) &#123;</span><br><span class="line">  this.push(elem * elem);</span><br><span class="line">&#125;, out);</span><br><span class="line"></span><br><span class="line">out // [1, 4, 9]</span><br></pre></td></tr></table></figure></p>
<p>注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。</p>
<p><strong>6.filter()</strong></p>
<p>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p>
<p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</p>
<p>filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</p>
<p><strong>7. some()，every()</strong></p>
<p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p>
<p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p>
<p>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.some(function (elem, index, arr) &#123;</span><br><span class="line">  return elem &gt;= 3;</span><br><span class="line">&#125;);</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果数组arr有一个成员大于等于3，some方法就返回true。</p>
<p>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.every(function (elem, index, arr) &#123;</span><br><span class="line">  return elem &gt;= 3;</span><br><span class="line">&#125;);</span><br><span class="line">// false</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，数组arr并非所有成员大于等于3，所以返回false。</p>
<p>注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isEven(x) &#123; return x % 2 === 0 &#125;</span><br><span class="line"></span><br><span class="line">[].some(isEven) // false</span><br><span class="line">[].every(isEven) // true</span><br></pre></td></tr></table></figure></p>
<p>some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</p>
<p><strong>8. reduce()，reduceRight()</strong></p>
<p>reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].reduce(function (a, b) &#123;</span><br><span class="line">  console.log(a, b);</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;)</span><br><span class="line">// 1 2</span><br><span class="line">// 3 3</span><br><span class="line">// 6 4</span><br><span class="line">// 10 5</span><br><span class="line">//最后结果：15</span><br></pre></td></tr></table></figure>
<p>上面代码中，reduce方法求出数组所有成员的和。第一次执行，a是数组的第一个成员1，b是数组的第二个成员2。第二次执行，a为上一轮的返回值3，b为第三个成员3。第三次执行，a为上一轮的返回值6，b为第四个成员4。第四次执行，a为上一轮返回值10，b为第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。</p>
<p>reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。</p>
<ol>
<li>累积变量，默认为数组的第一个成员</li>
<li>当前变量，默认为数组的第二个成员</li>
<li>当前位置（从0开始）</li>
<li>原数组</li>
</ol>
<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<p>如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].reduce(function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;, 10);</span><br><span class="line">// 25</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定参数a的初值为10，所以数组从10开始累加，最终结果为25。注意，这时b是从数组的第一个成员开始遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function substract(prev, cur) &#123;</span><br><span class="line">  return prev - cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[3, 2, 1].reduce(substract) // 0</span><br><span class="line">[3, 2, 1].reduceRight(substract) // -4</span><br></pre></td></tr></table></figure>
<p>上面代码中，reduce方法相当于3减去2再减去1，reduceRight方法相当于1减去2再减去3。</p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><h3 id="原始类型与实例对象的自动转换"><a href="#原始类型与实例对象的自动转换" class="headerlink" title="原始类型与实例对象的自动转换"></a>原始类型与实例对象的自动转换</h3><p>原始类型的值，可以自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。</p>
<p>比如，字符串可以调用length属性，返回字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.length // 3</span><br></pre></td></tr></table></figure>
<p>上面代码中，abc是一个字符串，本身不是对象，不能调用length属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">str.length // 3</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var strObj = new String(str)</span><br><span class="line">// String &#123;</span><br><span class="line">//   0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;</span><br><span class="line">// &#125;</span><br><span class="line">strObj.length // 3</span><br></pre></td></tr></table></figure>
<p>调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义.</p>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。</p>
<p>比如，我们可以新增一个double方法，使得字符串和数字翻倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.double = function () &#123;</span><br><span class="line">  return this.valueOf() + this.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&apos;abc&apos;.double()</span><br><span class="line">// abcabc</span><br><span class="line"></span><br><span class="line">Number.prototype.double = function () &#123;</span><br><span class="line">  return this.valueOf() + this.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(123).double()</span><br><span class="line">// 246</span><br></pre></td></tr></table></figure>
<p>但是，这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;abc&apos;;</span><br><span class="line"></span><br><span class="line">s.p = 123;</span><br><span class="line">s.p // undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码直接对字符串abc添加属性，结果无效。主要原因是上面说的，这里的包装对象是自动生成的，赋值后自动销毁，所以最后一行实际上调用的是一个新的包装对象。</p>
<h2 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h2><p><strong>Boolean 函数的类型转换作用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(0) // false</span><br><span class="line">Boolean(&apos;&apos;) // false</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line"></span><br><span class="line">Boolean(1) // true</span><br><span class="line">Boolean(&apos;false&apos;) // true</span><br><span class="line">Boolean([]) // true</span><br><span class="line">Boolean(&#123;&#125;) // true</span><br><span class="line">Boolean(function () &#123;&#125;) // true</span><br><span class="line">Boolean(/foo/) // true</span><br></pre></td></tr></table></figure>
<p>使用双重的否运算符（!）也可以将任意值转为对应的布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!!undefined // false</span><br><span class="line">!!null // false</span><br><span class="line">!!0 // false</span><br><span class="line">!!&apos;&apos; // false</span><br><span class="line">!!NaN // false</span><br><span class="line"></span><br><span class="line">!!1 // true</span><br><span class="line">!!&apos;false&apos; // true</span><br><span class="line">!![] // true</span><br><span class="line">!!&#123;&#125; // true</span><br><span class="line">!!function()&#123;&#125; // true</span><br><span class="line">!!/foo/ // true</span><br></pre></td></tr></table></figure>
<h2 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h2><p>Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。</p>
<p><code>(10).toString() // &quot;10&quot;</code></p>
<p>toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(10).toString(2) // &quot;1010&quot;</span><br><span class="line">(10).toString(8) // &quot;12&quot;</span><br><span class="line">(10).toString(16) // &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.toString(2)</span><br><span class="line">// SyntaxError: Unexpected token ILLEGAL</span><br></pre></td></tr></table></figure>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><h3 id="1-String-prototype-charAt"><a href="#1-String-prototype-charAt" class="headerlink" title="1. String.prototype.charAt()"></a>1. String.prototype.charAt()</h3><p>charAt方法返回指定位置的字符，参数是从0开始编号的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new String(&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">s.charAt(1) // &quot;b&quot;</span><br><span class="line">s.charAt(s.length - 1) // &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>这个方法完全可以用数组下标替代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charAt(1) // &quot;b&quot;</span><br><span class="line">&apos;abc&apos;[1] // &quot;b&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。</p>
<h3 id="2-String-prototype-concat"><a href="#2-String-prototype-concat" class="headerlink" title="2. String.prototype.concat()"></a>2. String.prototype.concat()</h3><p>concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &apos;abc&apos;;</span><br><span class="line">var s2 = &apos;def&apos;;</span><br><span class="line"></span><br><span class="line">s1.concat(s2) // &quot;abcdef&quot;</span><br><span class="line">s1 // &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>该方法可以接受多个参数。</p>
<p><code>&#39;a&#39;.concat(&#39;b&#39;, &#39;c&#39;) // &quot;abc&quot;</code></p>
<p>如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。</p>
<h3 id="3-String-prototype-substr"><a href="#3-String-prototype-substr" class="headerlink" title="3. String.prototype.substr()"></a>3. String.prototype.substr()</h3><p>substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。</p>
<h3 id="4-String-prototype-trim"><a href="#4-String-prototype-trim" class="headerlink" title="4. String.prototype.trim()"></a>4. String.prototype.trim()</h3><p>trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;  hello world  &apos;.trim()</span><br><span class="line">// &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\r\nabc \t&apos;.trim() // &apos;abc&apos;</span><br></pre></td></tr></table></figure>
<h3 id="5-String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#5-String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="5. String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>5. String.prototype.toLowerCase()，String.prototype.toUpperCase()</h3><p>toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;Hello World&apos;.toLowerCase()</span><br><span class="line">// &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">&apos;Hello World&apos;.toUpperCase()</span><br><span class="line">// &quot;HELLO WORLD&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-String-prototype-match"><a href="#6-String-prototype-match" class="headerlink" title="6. String.prototype.match()"></a>6. String.prototype.match()</h3><p>match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat, bat, sat, fat&apos;.match(&apos;at&apos;) // [&quot;at&quot;]</span><br><span class="line">&apos;cat, bat, sat, fat&apos;.match(&apos;xt&apos;) // null</span><br></pre></td></tr></table></figure></p>
<p>返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var matches = &apos;cat, bat, sat, fat&apos;.match(&apos;at&apos;);</span><br><span class="line">matches.index // 1</span><br><span class="line">matches.input // &quot;cat, bat, sat, fat&quot;</span><br></pre></td></tr></table></figure>
<h3 id="7-String-prototype-search-，String-prototype-replace"><a href="#7-String-prototype-search-，String-prototype-replace" class="headerlink" title="7. String.prototype.search()，String.prototype.replace()"></a>7. String.prototype.search()，String.prototype.replace()</h3><p>search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</p>
<p><code>&#39;cat, bat, sat, fat&#39;.search(&#39;at&#39;) // 1</code></p>
<p>replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</p>
<p><code>&#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot;</code></p>
<h3 id="8-String-prototype-split"><a href="#8-String-prototype-split" class="headerlink" title="8. String.prototype.split()"></a>8. String.prototype.split()</h3><p>split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p>
<p><code>&#39;a|b|c&#39;.split(&#39;|&#39;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code><br>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</p>
<p><code>&#39;a|b|c&#39;.split(&#39;&#39;) // [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</code><br>如果省略参数，则返回数组的唯一成员就是原字符串。</p>
<p><code>&#39;a|b|c&#39;.split() // [&quot;a|b|c&quot;]</code></p>
<h3 id="9-String-prototype-localeCompare"><a href="#9-String-prototype-localeCompare" class="headerlink" title="9. String.prototype.localeCompare()"></a>9. <u>String.prototype.localeCompare()</u></h3><p>localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;apple&apos;.localeCompare(&apos;banana&apos;) // -1</span><br><span class="line">&apos;apple&apos;.localeCompare(&apos;apple&apos;) // 0</span><br></pre></td></tr></table></figure></p>
<p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。</p>
<p><code>&#39;B&#39; &gt; &#39;a&#39; // false</code></p>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><h3 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h3><p>Math对象提供以下一些静态方法。</p>
<p>Math.abs()：绝对值<br>Math.ceil()：向上取整<br>Math.floor()：向下取整<br>Math.max()：最大值<br>Math.min()：最小值<br>Math.pow()：指数运算<br>Math.sqrt()：平方根<br>Math.log()：自然对数<br>Math.exp()：e的指数<br>Math.round()：四舍五入<br>Math.random()：随机数</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p>
<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>构造函数的特点有两个。</p>
<ul>
<li>函数体内部使用了this关键字，代表了所要生成的对象实例。</li>
<li>生成对象的时候，必须使用new命令。</li>
</ul>
<p><strong>下面先介绍new命令。</strong></p>
<p>new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐的写法</span><br><span class="line">var v = new Vehicle();</span><br><span class="line">// 不推荐的写法</span><br><span class="line">var v = new Vehicle;</span><br></pre></td></tr></table></figure></p>
<p><strong>new 命令的原理</strong></p>
<p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<h3 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">  age: 38,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    console.log(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person2 = Object.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name // 张三</span><br><span class="line">person2.greeting() // Hi! I&apos;m 张三.</span><br></pre></td></tr></table></figure></p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><h3 id="涵义"><a href="#涵义" class="headerlink" title="涵义"></a>涵义</h3><p>this可以用在构造函数之中，表示实例对象。除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。</p>
<p><strong>简单说，this就是属性或方法“当前”所在的对象。</strong></p>
<p>总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。</p>
<h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<p><code>var obj = { foo:  5 };</code></p>
<p>上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。</p>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><ol>
<li>全局环境</li>
</ol>
<p>全局环境使用this，它指的就是顶层对象window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this === window // true</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(this === window);</span><br><span class="line">&#125;</span><br><span class="line">f() // true</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>构造函数</li>
</ol>
<p>构造函数中的this，指的是实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Obj = function (p) &#123;</span><br><span class="line">  this.p = p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>对象的方法</li>
</ol>
<p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</p>
<p>如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  p: &apos;Hello&apos;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: function() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b.m() // undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="使用注意点："><a href="#使用注意点：" class="headerlink" title="使用注意点："></a>使用注意点：</h3><ol>
<li>避免多层 this</li>
</ol>
<p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f1: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var f2 = function () &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line">// Object</span><br><span class="line">// Window</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>避免数组处理方法中的 this</li>
</ol>
<p>数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: &apos;hello&apos;,</span><br><span class="line">  p: [ &apos;a1&apos;, &apos;a2&apos; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(this.v + &apos; &apos; + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// undefined a1</span><br><span class="line">// undefined a2</span><br></pre></td></tr></table></figure>
<p>上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。</p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: &apos;hello&apos;,</span><br><span class="line">  p: [ &apos;a1&apos;, &apos;a2&apos; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(that.v+&apos; &apos;+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// hello a1</span><br><span class="line">// hello a2</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: &apos;hello&apos;,</span><br><span class="line">  p: [ &apos;a1&apos;, &apos;a2&apos; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(this.v + &apos; &apos; + item);</span><br><span class="line">    &#125;, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// hello a1</span><br><span class="line">// hello a2</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>避免回调函数中的 this</li>
</ol>
<p>回调函数中的this往往会改变指向，最好避免使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line">o.f = function () &#123;</span><br><span class="line">  console.log(this === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// jQuery 的写法</span><br><span class="line">$(&apos;#button&apos;).on(&apos;click&apos;, o.f);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<h3 id="this-绑定方法"><a href="#this-绑定方法" class="headerlink" title="this 绑定方法"></a>this 绑定方法</h3><p>JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p>
<h4 id="1-Function-prototype-call"><a href="#1-Function-prototype-call" class="headerlink" title="1. Function.prototype.call()"></a>1. Function.prototype.call()</h4><p>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function () &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === window // true</span><br><span class="line">f.call(obj) === obj // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。</p>
<p>call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var n = 123;</span><br><span class="line">var obj = &#123; n: 456 &#125;;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call() // 123</span><br><span class="line">a.call(null) // 123</span><br><span class="line">a.call(undefined) // 123</span><br><span class="line">a.call(window) // 123</span><br><span class="line">a.call(obj) // 456</span><br></pre></td></tr></table></figure></p>
<p>call方法还可以接受多个参数。</p>
<p><code>func.call(thisValue, arg1, arg2, ...)</code></p>
<p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(this, 1, 2) // 3</span><br></pre></td></tr></table></figure>
<h4 id="2-Function-prototype-apply"><a href="#2-Function-prototype-apply" class="headerlink" title="2. Function.prototype.apply()"></a>2. Function.prototype.apply()</h4><p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<p><code>func.apply(thisValue, [arg1, arg2, ...])</code></p>
<p>apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(x, y)&#123;</span><br><span class="line">  console.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(null, 1, 1) // 2</span><br><span class="line">f.apply(null, [1, 1]) // 2</span><br></pre></td></tr></table></figure>
<p><strong>应用</strong></p>
<ul>
<li>找出数组最大元素</li>
</ul>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [10, 2, 4, 15, 9];</span><br><span class="line">Math.max.apply(null, a) // 15</span><br></pre></td></tr></table></figure></p>
<ul>
<li>转换类似数组的对象</li>
</ul>
<p>另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) // [1]</span><br><span class="line">Array.prototype.slice.apply(&#123;0: 1&#125;) // []</span><br><span class="line">Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined]</span><br><span class="line">Array.prototype.slice.apply(&#123;length: 1&#125;) // [undefined]</span><br></pre></td></tr></table></figure>
<ul>
<li>绑定回调函数的对象</li>
</ul>
<h4 id="3-Function-prototype-bind"><a href="#3-Function-prototype-bind" class="headerlink" title="3. Function.prototype.bind()"></a>3. Function.prototype.bind()</h4><p>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</p>
<h4 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h4><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。</p>
<p>那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。</p>

      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>如果觉得还不错，赏一个吧～</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wx_reward.png" alt="Wuguanghua 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/ailpay_reward.jpeg" alt="Wuguanghua 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/React-Native-Mobx一步步搭建项目/" rel="next" title="React Native + Mobx一步步搭建项目">
                <i class="fa fa-chevron-left"></i> React Native + Mobx一步步搭建项目
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjcxOS8xMzI1NA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://raw.githubusercontent.com/Wuguanghua/Wuguanghua.github.io/master/images/touxaing.png"
                alt="Wuguanghua" />
            
              <p class="site-author-name" itemprop="name">Wuguanghua</p>
              <p class="site-description motion-element" itemprop="description">to be better!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Wuguanghua" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/594d1bea8d6d810057ef6562" target="_blank" title="掘金"><i class="fa fa-fw fa-globe"></i>掘金</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://www.zhihu.com/people/super5577" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://weibo.com/" target="_blank" title="微博"><i class="fa fa-fw fa-globe"></i>微博</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://segmentfault.com/u/super77" target="_blank" title="segmentfault"><i class="fa fa-fw fa-globe"></i>segmentfault</a>
                  
                </span>
              
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本语法"><span class="nav-number">1.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-注释"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-条件语句"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标签（label）"><span class="nav-number">1.0.3.</span> <span class="nav-text">标签（label）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">2.0.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-typeof-运算符"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">1.typeof 运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null-undefined-和布尔值"><span class="nav-number">2.0.2.</span> <span class="nav-text">null, undefined 和布尔值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在if语句中，它们都会被自动转为false，相等运算符（-）甚至直接报告两者相等。"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用法和含义"><span class="nav-number">2.0.2.1.1.</span> <span class="nav-text">用法和含义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔值"><span class="nav-number">2.0.2.2.</span> <span class="nav-text">布尔值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值"><span class="nav-number">2.0.3.</span> <span class="nav-text">数值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数值相关的全局方法"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">数值相关的全局方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">2.0.4.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">2.0.5.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述-1"><span class="nav-number">2.0.5.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的引用"><span class="nav-number">2.0.5.1.1.</span> <span class="nav-text">对象的引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">2.0.6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参数"><span class="nav-number">2.0.6.1.</span> <span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#arguments-对象"><span class="nav-number">2.0.6.1.1.</span> <span class="nav-text">arguments 对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包"><span class="nav-number">2.0.6.2.</span> <span class="nav-text">闭包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.0.7.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类似数组的对象"><span class="nav-number">2.0.7.1.</span> <span class="nav-text">类似数组的对象</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-number">3.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算数运算符"><span class="nav-number">3.1.</span> <span class="nav-text">算数运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本规则："><span class="nav-number">3.1.1.</span> <span class="nav-text">基本规则：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较运算符"><span class="nav-number">3.2.</span> <span class="nav-text">比较运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔运算符"><span class="nav-number">3.2.1.</span> <span class="nav-text">布尔运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他运算符"><span class="nav-number">3.2.2.</span> <span class="nav-text">其他运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#语法"><span class="nav-number">4.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型的转换"><span class="nav-number">4.1.</span> <span class="nav-text">数据类型的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强制转换"><span class="nav-number">4.1.1.</span> <span class="nav-text">强制转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Number"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">Number()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">String()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理机制"><span class="nav-number">4.2.</span> <span class="nav-text">错误处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Error-实例对象"><span class="nav-number">4.2.1.</span> <span class="nav-text">Error 实例对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原生错误类型"><span class="nav-number">4.2.2.</span> <span class="nav-text">原生错误类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制台-console"><span class="nav-number">4.3.</span> <span class="nav-text">控制台 console</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准库"><span class="nav-number">5.</span> <span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-对象"><span class="nav-number">5.1.</span> <span class="nav-text">Object 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-对象"><span class="nav-number">5.2.</span> <span class="nav-text">Array 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法"><span class="nav-number">5.2.1.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例方法"><span class="nav-number">5.2.2.</span> <span class="nav-text">实例方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装对象"><span class="nav-number">5.3.</span> <span class="nav-text">包装对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原始类型与实例对象的自动转换"><span class="nav-number">5.3.1.</span> <span class="nav-text">原始类型与实例对象的自动转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义方法"><span class="nav-number">5.3.2.</span> <span class="nav-text">自定义方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boolean-对象"><span class="nav-number">5.4.</span> <span class="nav-text">Boolean 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-对象"><span class="nav-number">5.5.</span> <span class="nav-text">Number 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-对象"><span class="nav-number">5.6.</span> <span class="nav-text">String 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-String-prototype-charAt"><span class="nav-number">5.6.1.</span> <span class="nav-text">1. String.prototype.charAt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-String-prototype-concat"><span class="nav-number">5.6.2.</span> <span class="nav-text">2. String.prototype.concat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-String-prototype-substr"><span class="nav-number">5.6.3.</span> <span class="nav-text">3. String.prototype.substr()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-String-prototype-trim"><span class="nav-number">5.6.4.</span> <span class="nav-text">4. String.prototype.trim()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-String-prototype-toLowerCase-，String-prototype-toUpperCase"><span class="nav-number">5.6.5.</span> <span class="nav-text">5. String.prototype.toLowerCase()，String.prototype.toUpperCase()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-String-prototype-match"><span class="nav-number">5.6.6.</span> <span class="nav-text">6. String.prototype.match()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-String-prototype-search-，String-prototype-replace"><span class="nav-number">5.6.7.</span> <span class="nav-text">7. String.prototype.search()，String.prototype.replace()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-String-prototype-split"><span class="nav-number">5.6.8.</span> <span class="nav-text">8. String.prototype.split()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-String-prototype-localeCompare"><span class="nav-number">5.6.9.</span> <span class="nav-text">9. String.prototype.localeCompare()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-对象"><span class="nav-number">5.7.</span> <span class="nav-text">Math 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法-1"><span class="nav-number">5.7.1.</span> <span class="nav-text">静态方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程"><span class="nav-number">6.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">6.1.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">6.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create-创建实例对象"><span class="nav-number">6.1.2.</span> <span class="nav-text">Object.create() 创建实例对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-关键字"><span class="nav-number">6.2.</span> <span class="nav-text">this 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#涵义"><span class="nav-number">6.2.1.</span> <span class="nav-text">涵义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实质"><span class="nav-number">6.2.2.</span> <span class="nav-text">实质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场合"><span class="nav-number">6.2.3.</span> <span class="nav-text">使用场合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用注意点："><span class="nav-number">6.2.4.</span> <span class="nav-text">使用注意点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-绑定方法"><span class="nav-number">6.2.5.</span> <span class="nav-text">this 绑定方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Function-prototype-call"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">1. Function.prototype.call()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Function-prototype-apply"><span class="nav-number">6.2.5.2.</span> <span class="nav-text">2. Function.prototype.apply()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Function-prototype-bind"><span class="nav-number">6.2.5.3.</span> <span class="nav-text">3. Function.prototype.bind()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prototype-属性的作用"><span class="nav-number">6.2.5.4.</span> <span class="nav-text">prototype 属性的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-number">6.2.6.</span> <span class="nav-text">原型链</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wuguanghua</span>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  

  
</div>




本站总访问量<span id="busuanzi_value_site_pv"></span>次
本站访客数<span id="busuanzi_value_site_uv"></span>人次



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("hz3Qcdi8gOtJATW4cxzaKtlg-gzGzoHsz", "J2fIILU9fLODEQO6r5wLOAav");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var newcounter = new Counter();
              /* Set ACL */
              var acl = new AV.ACL();
              acl.setPublicReadAccess(true);
              acl.setPublicWriteAccess(true);
              newcounter.setACL(acl);
              /* End Set ACL */
              newcounter.set("title", title);
              newcounter.set("url", url);
              newcounter.set("time", 1);
              newcounter.save(null, {
                success: function(newcounter) {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                },
                error: function(newcounter, error) {
                  console.log('Failed to create');
                }
              });
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
